input {
  snmp {
    hosts => {{ es_master_http }}
              { host => "udp:10.96.10.102/161" community => "public" version => "2c"}
             ]
    add_field => {host => "%{[@metadata][host_protocol]}:%{[@metadata][host_address]}/%{[@metadata][host_port]},%{[@metadata][host_community]}"}
    add_field => {host_address => "%{[@metadata][host_address]}"}
    add_field => {host_community => "%{[@metadata][host_community]}"}
    tables =>  [
                 { "name" => "interface" "columns" => ["1.3.6.1.2.1.31.1.1.1.18", "1.3.6.1.2.1.31.1.1.1.1", "1.3.6.1.2.1.2.2.1.2", "1.3.6.1.2.1.2.2.1.21", "1.3.6.1.2.1.2.2.1.8", "1.3.6.1.2.1.2.2.1.7","1.3.6.1.2.1.2.2.1.14", "1.3.6.1.2.1.2.2.1.20", "1.3.6.1.2.1.2.2.1.13", "1.3.6.1.2.1.2.2.1.19", "1.3.6.1.2.1.2.2.1.5", "1.3.6.1.2.1.31.1.1.1.15", "1.3.6.1.2.1.31.1.1.1.6", "1.3.6.1.2.1.31.1.1.1.10"] }
               ]
    interval => 30
    tags => QFX_snmp_alert
  }
}

filter {
  if "QFX_snmp_alert" in [tags] {
    mutate {
      rename => { "[ilo_nic][0][iso.org.dod.internet.private.enterprises.232.9.2.5.1.1.14]" => "ilo_fqdn" }
      remove_field => ["ilo_nic"]
    }

    ruby {
      id => "QFX-SNMP-ruby-01"
      code => '
        event.set("[@metadata][tables_name]", ["interface"])
        result = Array.new
        event.get("[@metadata][tables_name]").each { |key|
          i = event.get(key)
          result = result + i
          event.remove(key)
        }
        event.set("[@metadata][result]", result)
      '
    }

    split {
      id => "QFX-SNMP-split"
      field => "[@metadata][result]"
    }

    ruby {
      id => "QFX-SNMP-ruby-02"
      code => '
        file = File.open("/etc/logstash/dictionary/QFX_oid_mapping.txt", "r")
        data = file.readlines
        mapping_data = []
        data.each{ |item|
          data_split = item.split("=")
          mapping_data << { "name" => data_split[0], "oid" => data_split[1].sub("\r\n", "").sub("\n", "") }
        }
        get_name = ""
        index_value = ""
        event.get("[@metadata][result]").each { |key, value|
          if (key =~ /iso.org/)
            compare_key = key.gsub(/\.\d+$/, "")
            mapping_data.each { |item|
              if (item["oid"] == key)
                get_name = item["name"].gsub(/\..*/, "")
                event.set(item["name"].gsub(/\w+\./, ""), value)
                event.remove(key)
              end
            }
          end
          if (key =~ /index/)
            index_value = value
          end

        }
        event.set("index", get_name + "_index_" + index_value)
      '
    }
 
    # QFX - TRANSLATE INTERFACE OID DESC #
    if "interface" in [@metadata][tables_name] {
      if ([ifOperStatus]) { translate { source => "[ifOperStatus]" target => "[ifOperStatus_desc]" exact => true dictionary_path => "/etc/logstash/dictionary/qfx/ifOperStatus.yml" } }
      if ([ifAdminStatus]) { translate { source => "[ifAdminStatus]" target => "[ifAdminStatus_desc]" exact => true dictionary_path => "/etc/logstash/dictionary/qfx/ifAdminStatus.yml" } }
    }
  }
}


output {
#  stdout {
#    codec => rubydebug
#  }

  if "QFX_snmp_alert" in [tags] {
    elasticsearch {
      index => "snmp-qfx"
      hosts => {{ es_master_http }}
      cacert => "/etc/logstash/certs/{{ inventory_hostname }}.pem"
      user => "{{ beats.logstash.logstash_writer.username }}"
      password => "{{ beats.logstash.logstash_writer.password }}"
      ssl_certificate_verification => false
    }
  }
}
