input {
  tcp {
    port => 5514
    type => syslog
    tags => junos_log
  }
  udp {
    port => 5514
    type => syslog
    tags => junos_log
  }
}

filter {
  if "junos_log" in [tags] {
    mutate {
      add_field => [ "received_at", "%{@timestamp}" ]
      add_field => [ "received_from", "%{host}" ]
    }
    if ([message] =~ /nginx health check/) {
        drop {}
    }
    if ([message] =~ /haproxy/) {
        drop {}
    }
    if [message] =~ "- - - - fpc" {
        drop {}
    }
    if [host] =~ /10.248.241.226/ or [host] =~ /10.248.241.228/ {
        drop {}
    }
    else {
      grok {
        match => { "message" => "<%{PRIORITYCODE:junos_priocode}>1 %{TIMESTAMP_ISO8601:junos_time} %{JUNHOSTNAME:junos_hostname} (%{PROCESSNAME:junos_procsname}|\-) (%{PROCESSID:junos_procsid}|\-) (%{EVENTNAME:junos_eventname}|\-) %{MESSAGE:junos_msg}" }
        patterns_dir => ["/etc/logstash/patterns"]
        patterns_files_glob => "structured_log"
      }
    }

    mutate {
      convert => { "junos_priocode" => "integer" }
    }
    ruby { 
      code => 'event.set("junos_facilitycode", event.get("junos_priocode")/8)'
    }
    ruby { 
      code => 'event.set("junos_severitycode", event.get("junos_priocode")%8)'
    }
    translate {
      source => "[junos_severitycode]"
      target => "[junos_severityname]"
      dictionary_path => "/etc/logstash/dictionary/severitycode.yml"   
    }
    translate {
      source => "[junos_facilitycode]"
      target => "[junos_facilityname]"
      dictionary_path => "/etc/logstash/dictionary/facilitycode.yml"
    }

    grok {  
        match => ["junos_facilityname", "AUTHORIZATION"]   
        match => ["junos_procsname", "sshd|login"]
        add_tag => "access_log"
    }

    grok {
        match => ["junos_eventname", "UI_LOGOUT_EVENT|UI_LOGIN_EVENT|UI_AUTH_EVENT|UI_CMDLINE_READ_LINE"]
        match => ["junos_facilityname", "INTERACTIVE-COMMANDS"]
        match => ["junos_procsname", "mgd"]
        add_tag => "access_log"
    }

    if "access_log" in [tags] {
      mutate { add_field => {"login_session" => "pending"} }
    }

    if "UI_JUNOSCRIPT_CMD" in [junos_eventname] {
       mutate { update => {"login_session" => "junos_script"} }
    }

    grok {
        # TELNET/SSH FAILED
        match => { "junos_msg" => "\[%{GREEDYDATA:} username=\"%{GREEDYDATA:login_user}\" source-address=\"%{IP:login_source}\"\] %{GREEDYDATA:}" }
        add_field => { "login_protocol" => "login failed" }
        add_tag => "login_trigger"
        tag_on_failure => []
    }

    grok {
        # TELNET OK
        match => { "junos_msg" => "\[%{GREEDYDATA:} username=\"%{GREEDYDATA:login_user}\" hostname=\"%{IP:login_source}\" tty-name=\"%{GREEDYDATA:client_mode}\"\] %{GREEDYDATA:}" }
        # SSH OK
        match => { "junos_msg" => "\[%{DATA} username=\"%{GREEDYDATA:login_user}\" class-name=\"%{GREEDYDATA:class}\" local-peer=\"%{DATA}\" ssh-connection=\"%{IP:login_source} %{DATA}\" client-mode=\"%{GREEDYDATA:client_mode}\"\] %{GREEDYDATA:}" }
        # Junoscript
        match => { "junos_msg" => "\[%{DATA} username=\"%{GREEDYDATA:login_user}\" class-name=\"%{GREEDYDATA:class}\" local-peer=\"%{DATA}\" %{GREEDYDATA:} client-mode=\"(?<client_mode>\junoscript)\"\] %{GREEDYDATA:}" }
        add_tag => "login_trigger"
        tag_on_failure => []
    }

    grok {
        # TELNET/SSH COMMAND - Interacetive User
        match => { "junos_msg" => "\[%{GREEDYDATA:}\] User '%{GREEDYDATA:login_user}', command '%{GREEDYDATA:junos_command}'" }
        add_tag => "interactive_user"
        tag_on_failure => []
    }

    grok {
        # NETCONF COMMAND - NETCONF User
        match => { "junos_msg" => "\[%{GREEDYDATA:}\] User '%{GREEDYDATA:login_user}' used NETCONF client to run command '%{GREEDYDATA:junos_command}'" }
        match => { "junos_msg" => "\[%{GREEDYDATA:}\] User '%{GREEDYDATA:login_user}', command 'xml-mode netconf need-trailer '" }
        match => { "junos_msg" => "\[%{GREEDYDATA:}\] User '%{GREEDYDATA:login_user}', command 'command rpc rpc command start shell command %{GREEDYDATA:}" }
        add_tag => "netconf_user"
        add_field => { "client_mode" => "netconf" }
        tag_on_failure => []
    }

    translate {
      exact => true
      regex => true
      source => "[client_mode]"
      target => "[login_protocol]"
      dictionary_path => "/etc/logstash/dictionary/client_mode.yml"
    }

    date {
      match => [ "junos_time", "ISO8601" ]
    }

    mutate {
      remove_field => [ "message" ]
    }
  }
}

output {
  if "junos_log" in [tags] or "access_log" in [tags] or "interactive_user" in [tags] or "netconf_user" in [tags] or "login_trigger" in [tags] {
    elasticsearch {
      hosts => {{ es_master_http }}
      index => "junos-log"
      cacert => "/etc/logstash/certs/{{ inventory_hostname }}.pem"
      user => "{{ beats.logstash.logstash_writer.username }}"
      password => "{{ beats.logstash.logstash_writer.password }}"
      ssl_certificate_verification => false
    }
  }

  if "_grokparsefailure" in [tags] {
    file { path => "/tmp/logstash_failed_parse_events-%{+YYYY-MM}" }
  }
}
